<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Press Scheduling Optimization Tool</title>
    <style>
        :root {
            --bg-color: #fff;
            --text-color: #333;
            --card-bg: #f9f9f9;
            --border-color: #ddd;
            --primary-color: #4CAF50;
            --secondary-color: #2196f3;
            --warning-color: #FFC107;
            --danger-color: #f44336;
            --header-bg: #f2f2f2;
            --same-die-color: #d4edda;
            --same-substrate-color: #d1ecf1;
            --same-plates-color: #fff3cd;
        }
        
        .dark-mode {
            --bg-color: #222;
            --text-color: #eee;
            --card-bg: #333;
            --border-color: #444;
            --primary-color: #5cb85c;
            --secondary-color: #3aa0ff;
            --warning-color: #ffce3a;
            --danger-color: #ff5c5c;
            --header-bg: #444;
            --same-die-color: #1e392a;
            --same-substrate-color: #1e3c47;
            --same-plates-color: #3e3624;
        }
        
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--bg-color);
            margin: 0;
            padding: 20px;
            transition: background-color 0.3s, color 0.3s;
        }
        
        h1, h2, h3, h4 {
            margin-top: 0;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .dark-mode-toggle {
            display: flex;
            align-items: center;
        }
        
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 30px;
            margin-left: 10px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 30px;
        }
        
        .slider:before {
            position: absolute;
            content: "";
            height: 22px;
            width: 22px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .slider {
            background-color: var(--primary-color);
        }
        
        input:checked + .slider:before {
            transform: translateX(30px);
        }
        
        .card {
            background-color: var(--card-bg);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        textarea {
            width: 100%;
            height: 300px;
            margin-bottom: 10px;
            font-family: monospace;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--bg-color);
            color: var(--text-color);
        }
        
        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
            transition: background-color 0.3s, transform 0.2s;
        }
        
        button:hover {
            filter: brightness(1.05);
        }
        
        button:active {
            transform: translateY(1px);
        }
        
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        button.btn-secondary {
            background-color: var(--secondary-color);
        }
        
        button.btn-warning {
            background-color: var(--warning-color);
            color: #333;
        }
        
        button.btn-danger {
            background-color: var(--danger-color);
        }
        
        input[type="number"] {
            width: 60px;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--bg-color);
            color: var(--text-color);
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-row {
            display: flex;
            margin-bottom: 10px;
        }
        
        .form-row > * {
            margin-right: 20px;
        }
        
        .stats {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .stat-card {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 15px;
            flex: 1 0 auto;
            min-width: 150px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            margin-top: 5px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
            font-size: 14px;
        }
        
        th, td {
            padding: 10px;
            border: 1px solid var(--border-color);
            text-align: left;
        }
        
        th {
            background-color: var(--header-bg);
            position: sticky;
            top: 0;
        }
        
        tr:nth-child(even) {
            background-color: rgba(0,0,0,0.05);
        }
        
        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border: 1px solid transparent;
            border-bottom: none;
            border-radius: 4px 4px 0 0;
            background-color: var(--card-bg);
            margin-right: 5px;
        }
        
        .tab.active {
            border-color: var(--border-color);
            background-color: var(--bg-color);
            margin-bottom: -1px;
        }
        
        .tab-content {
            display: none;
            padding: 20px;
            background-color: var(--bg-color);
            border: 1px solid var(--border-color);
            border-top: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .urgent {
            background-color: rgba(255, 0, 0, 0.1);
        }
        
        .approaching-due {
            background-color: rgba(255, 165, 0, 0.1);
        }
        
        .optimized {
            font-weight: bold;
        }
        
        .same-die {
            background-color: var(--same-die-color);
        }
        
        .same-substrate {
            background-color: var(--same-substrate-color);
        }
        
        .same-plates {
            background-color: var(--same-plates-color);
        }
        
        .timeline {
            position: relative;
            margin-top: 50px;
            margin-bottom: 50px;
            overflow-x: auto;
        }
        
        .timeline-container {
            position: relative;
            min-width: 100%;
        }
        
        .timeline-track {
            position: relative;
            height: 30px;
            margin-bottom: 10px;
        }
        
        .timeline-label {
            position: absolute;
            left: 0;
            top: -20px;
            font-weight: bold;
        }
        
        .timeline-job {
            position: absolute;
            height: 100%;
            background-color: var(--primary-color);
            border-radius: 4px;
            color: white;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding: 0 5px;
        }
        
        .timeline-job.optimized {
            background-color: var(--secondary-color);
        }
        
        .tooltip {
            position: absolute;
            background-color: rgba(0,0,0,0.8);
            color: white;
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 100;
            max-width: 250px;
            display: none;
        }
        
        .tooltip-title {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .timeline-scale {
            position: relative;
            height: 20px;
            border-top: 1px solid var(--border-color);
            margin-top: 20px;
        }
        
        .timeline-marker {
            position: absolute;
            top: -10px;
            transform: translateX(-50%);
            font-size: 12px;
            text-align: center;
        }
        
        .timeline-marker::before {
            content: '';
            display: block;
            height: 10px;
            width: 1px;
            background-color: var(--border-color);
            margin: 0 auto;
        }
        
        .file-input-container {
            display: flex;
            margin-bottom: 10px;
        }
        
        .file-input-container input[type="file"] {
            display: none;
        }
        
        .file-input-container label {
            background-color: #f5f5f5;
            color: #333;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid #ddd;
            transition: background-color 0.3s;
        }
        
        .file-input-container label:hover {
            background-color: #e8e8e8;
        }
        
        .file-name {
            margin-left: 10px;
            line-height: 2.2;
        }
        
        .press-selector {
            margin-bottom: 10px;
        }
        
        .press-checkbox {
            margin-right: 15px;
        }
        
        /* Enhanced Loading indicator */
        .loading {
            text-align: center;
            padding: 20px;
            font-style: italic;
            color: #888;
        }
        
        /* Enhanced Error messages */
        .error {
            background-color: #fff0f0;
            border-left: 4px solid #ff3333;
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
        }
        
        /* Enhanced Success messages */
        .success-message {
            background-color: #f0fff0;
            border-left: 4px solid #33cc33;
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
        }
        
        /* Animation for analyze button */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        #analyzeBtn:hover {
            animation: pulse 1s infinite;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Press Scheduling Optimization Tool</h1>
            <div class="dark-mode-toggle">
                <span>🌙 Dark Mode</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="darkModeCheckbox">
                    <span class="slider"></span>
                </label>
            </div>
        </div>
        
        <p>Optimize label printing schedules to minimize changeovers while respecting ship dates.</p>
        
        <div class="card">
            <h2>Input Schedule Data</h2>
            
            <div class="file-input-container">
                <input type="file" id="fileInput" accept=".csv,.txt,.tsv">
                <label for="fileInput">Choose File</label>
                <span class="file-name" id="fileName">No file chosen</span>
            </div>
            
            <div>
                <button id="loadFileBtn">Load File</button>
                <button id="loadSampleBtn" class="btn-secondary">Load Sample Data</button>
            </div>
            
            <textarea id="inputData" placeholder="Paste your tab-delimited schedule data here..."></textarea>
            
            <div>
                <button id="analyzeBtn">Analyze Schedule Data</button>
                <button id="optimizeBtn" disabled>Optimize Schedule</button>
                <button id="exportBtn" disabled>Copy to Clipboard</button>
                <button id="downloadBtn" disabled>Download CSV</button>
                <button id="clearBtn" class="btn-danger">Clear Data</button>
            </div>
        </div>
        
        <div class="card">
            <h2>Optimization Parameters</h2>
            
            <div class="form-row">
                <div class="form-group">
                    <label>Die Change Time (min):</label>
                    <input type="number" id="dieTime" value="15" min="0">
                </div>
                
                <div class="form-group">
                    <label>Material Change Time (min):</label>
                    <input type="number" id="materialTime" value="10" min="0">
                </div>
                
                <div class="form-group">
                    <label>Color Setup Time per Cylinder (min):</label>
                    <input type="number" id="colorTime" value="3" min="0">
                </div>
            </div>
            
            <div class="form-row">
                <div class="form-group">
                    <input type="checkbox" id="prioritizeShipDates" checked>
                    <label for="prioritizeShipDates">Prioritize ship dates</label>
                </div>
                
                <div class="form-group">
                    <input type="checkbox" id="groupByDie" checked>
                    <label for="groupByDie">Group by Die ID</label>
                </div>
            </div>
        </div>
        
        <div class="card">
            <h2>Analysis Summary</h2>
            <div id="analysisSummary">
                Paste data and click "Analyze Schedule Data" to begin.
            </div>
        </div>
        
        <div id="resultTabs" class="tabs" style="display:none;">
            <div class="tab active" data-tab="original">Original Schedule</div>
            <div class="tab" data-tab="optimized">Optimized Schedule</div>
            <div class="tab" data-tab="timeline">Schedule Timeline</div>
        </div>
        
        <div id="originalSchedule" class="tab-content active">
            <div id="pressSelectors" class="press-selector"></div>
            <table id="originalTable">
                <thead>
                    <tr>
                        <th>Date</th>
                        <th>Start Time</th>
                        <th>Duration</th>
                        <th>Job ID</th>
                        <th>Ship Date</th>
                        <th>Status</th>
                        <th>Customer</th>
                        <th>Die ID</th>
                        <th>Plate Count</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
        
        <div id="optimizedSchedule" class="tab-content">
            <div id="optimizationStats"></div>
            <table id="optimizedTable">
                <thead>
                    <tr>
                        <th>Date</th>
                        <th>Start Time</th>
                        <th>Duration</th>
                        <th>Job ID</th>
                        <th>Ship Date</th>
                        <th>Status</th>
                        <th>Customer</th>
                        <th>Die ID</th>
                        <th>Plate Count</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
        
        <div id="timelineView" class="tab-content">
            <div id="timelineContainer" class="timeline">
                <!-- Timeline will be generated dynamically -->
            </div>
        </div>
    </div>
    
    <script>
        // DOM elements
        const inputDataEl = document.getElementById('inputData');
        const analyzeBtnEl = document.getElementById('analyzeBtn');
        const optimizeBtnEl = document.getElementById('optimizeBtn');
        const exportBtnEl = document.getElementById('exportBtn');
        const downloadBtnEl = document.getElementById('downloadBtn');
        const clearBtnEl = document.getElementById('clearBtn');
        const analysisSummaryEl = document.getElementById('analysisSummary');
        const optimizationStatsEl = document.getElementById('optimizationStats');
        const statsContainerEl = document.getElementById('statsContainer');
        const optimizationSummaryEl = document.getElementById('optimizationSummary');
        const tabsEl = document.querySelectorAll('.tab');
        const tabContentsEl = document.querySelectorAll('.tab-content');
        const resultTabsEl = document.getElementById('resultTabs');
        const originalTableEl = document.getElementById('originalTable');
        const optimizedTableEl = document.getElementById('optimizedTable');
        const fileInputEl = document.getElementById('fileInput');
        const fileNameEl = document.getElementById('fileName');
        const loadFileBtnEl = document.getElementById('loadFileBtn');
        const loadSampleBtnEl = document.getElementById('loadSampleBtn');
        const pressSelectorsEl = document.getElementById('pressSelectors');
        const dieTimeEl = document.getElementById('dieTime');
        const materialTimeEl = document.getElementById('materialTime');
        const colorTimeEl = document.getElementById('colorTime');
        const prioritizeShipDatesEl = document.getElementById('prioritizeShipDates');
        const groupByDieEl = document.getElementById('groupByDie');
        const darkModeToggleEl = document.getElementById('darkModeCheckbox');
        const timelineContainerEl = document.getElementById('timelineContainer');
        
        // Global variables
        let originalJobs = [];
        let optimizedJobs = [];
        let pressTypes = [];
        let selectedPresses = [];
        const today = new Date();
        
        // Tab switching
        tabsEl.forEach(tab => {
            tab.addEventListener('click', () => {
                tabsEl.forEach(t => t.classList.remove('active'));
                tabContentsEl.forEach(tc => tc.classList.remove('active'));
                
                tab.classList.add('active');
                const tabId = tab.getAttribute('data-tab');
                const tabContent = document.getElementById(tabId + 'Schedule');
                if (tabId === 'timeline') {
                    document.getElementById('timelineView').classList.add('active');
                } else if (tabContent) {
                    tabContent.classList.add('active');
                }
            });
        });
        
        // Dark mode toggle
        const darkModeFromStorage = localStorage.getItem('darkMode') === 'true';
        darkModeCheckboxEl.checked = darkModeFromStorage;
        if (darkModeFromStorage) {
            document.body.classList.add('dark-mode');
        }
        
        // Dark mode toggle
        darkModeToggleEl.addEventListener('click', function() {
            document.body.classList.toggle('dark-mode');
            darkModeCheckboxEl.checked = document.body.classList.contains('dark-mode');
            localStorage.setItem('darkMode', darkModeCheckboxEl.checked);
        });
        
        darkModeCheckboxEl.addEventListener('change', function() {
            document.body.classList.toggle('dark-mode', this.checked);
            localStorage.setItem('darkMode', this.checked);
        });
        
        // File input handling
        fileInputEl.addEventListener('change', function() {
            if (this.files.length > 0) {
                fileNameEl.textContent = this.files[0].name;
            } else {
                fileNameEl.textContent = 'No file chosen';
            }
        });
        
        loadFileBtnEl.addEventListener('click', function() {
            if (fileInputEl.files.length === 0) {
                alert('Please select a file first.');
                return;
            }
            
            const file = fileInputEl.files[0];
            const reader = new FileReader();
            
            reader.onload = function(e) {
                inputDataEl.value = e.target.result;
            };
            
            reader.readAsText(file);
        });
        
        // Sample data loading
        loadSampleBtnEl.addEventListener('click', function() {
            const sampleData = `PRESS_SMAG_1
Date	Start Time	Duration	Job ID	Ship Date	Notes	Status	Customer	Description	Graphics	Plates	New/Repeat	RollStock	Finishing	Die ID	Machine	Scratch Quantity	Plate Count	Paper Width	Substrate	Full Substrate	Total Footage
3/11/2025	10:21	1:53	J-61030	3/21/2025		FreshFoods	Label	4.25"	BOPP	BOPP 2mil	Repeat	10000	Regular	PRESS_SMAG_1	Product	4	D-1006
3/15/2025	8:54	1:36	J-30550	3/26/2025		GreenPackaging	Label	4.25"	PET	PET 2mil	Repeat	10000	Regular	PRESS_SMAG_1	Product	1	D-1004
3/8/2025	10:59	2:08	J-57039	3/24/2025		Acme Foods	Label	4.25"	Vinyl	Vinyl 2mil	Repeat	10000	Regular	PRESS_SMAG_1	Product	4	D-1007
3/8/2025	15:57	3:37	J-33733	3/29/2025		BioProducts	Label	4.25"	PP	PP 2mil	Repeat	10000	Regular	PRESS_SMAG_1	Product	4	D-1004
3/28/2025	13:19	1:32	J-61064	4/8/2025		TechCorp	Label	4.25"	BOPP	BOPP 2mil	Repeat	10000	Regular	PRESS_SMAG_1	Product	4	D-1006
3/12/2025	11:25	1:44	J-14478	3/16/2025		TechCorp	Label	4.25"	BOPP	BOPP 2mil	Repeat	10000	Regular	PRESS_SMAG_1	Product	1	D-1002
3/27/2025	11:47	1:59	J-37936	4/11/2025		GreenPackaging	Label	4.25"	PP	PP 2mil	Repeat	10000	Regular	PRESS_SMAG_1	Product	1	D-1003
3/12/2025	15:12	3:11	J-21917	3/31/2025		FreshFoods	Label	4.25"	Vinyl	Vinyl 2mil	Repeat	10000	Regular	PRESS_SMAG_1	Product	1	D-1004
3/21/2025	11:07	3:56	J-68676	3/30/2025		BioProducts	Label	4.25"	PET	PET 2mil	Repeat	10000	Regular	PRESS_SMAG_1	Product	1	D-1003
3/24/2025	15:19	3:48	J-55103	3/23/2025		TechCorp	Label	4.25"	PP	PP 2mil	Repeat	10000	Regular	PRESS_SMAG_1	Product	3	D-1007`;
            
            inputDataEl.value = sampleData;
        });
        
        // Clear button
        clearBtnEl.addEventListener('click', function() {
            inputDataEl.value = '';
            analysisSummaryEl.innerHTML = 'Paste data and click "Analyze Schedule Data" to begin.';
            originalJobs = [];
            optimizedJobs = [];
            pressTypes = [];
            selectedPresses = [];
            
            originalTableEl.querySelector('tbody').innerHTML = '';
            optimizedTableEl.querySelector('tbody').innerHTML = '';
            optimizationStatsEl.innerHTML = '';
            pressSelectorsEl.innerHTML = '';
            
            resultTabsEl.style.display = 'none';
            optimizeBtnEl.disabled = true;
            exportBtnEl.disabled = true;
            downloadBtnEl.disabled = true;
            
            fileInputEl.value = '';
            fileNameEl.textContent = 'No file chosen';
        });
        
        // Event Handlers
        analyzeBtnEl.addEventListener('click', () => {
            // Show loading indicator
            analysisSummaryEl.innerHTML = '<div class="loading">Analyzing data...</div>';
            
            setTimeout(() => {
                try {
                    const data = inputDataEl.value;
                    if (!data) {
                        analysisSummaryEl.innerHTML = '<div class="error">Please paste schedule data first!</div>';
                        return;
                    }
                    
                    // Parse data with improved error handling
                    originalJobs = parseScheduleData(data);
                    
                    if (originalJobs.length === 0) {
                        analysisSummaryEl.innerHTML = `
                            <div class="error">
                                <h3>No valid job data found.</h3>
                                <p>Please check your input and ensure it contains:</p>
                                <ul>
                                    <li>Date information (MM/DD/YYYY format)</li>
                                    <li>Job details with proper column separators (tabs or commas)</li>
                                    <li>Header row with column names (optional but helpful)</li>
                                </ul>
                                <p>Or try loading the sample data for reference.</p>
                            </div>
                        `;
                        return;
                    }
                    
                    // Display analysis with count of successfully processed jobs
                    analysisSummaryEl.innerHTML = `
                        <div class="success-message">
                            <p>✓ Successfully processed ${originalJobs.length} jobs</p>
                        </div>
                        ${createAnalysisSummary(originalJobs)}
                    `;
                    
                    // Create press selectors
                    createPressSelectors();
                    
                    // Display original schedule
                    displayOriginalSchedule();
                    
                    // Show tabs
                    resultTabsEl.style.display = 'flex';
                    
                    // Enable optimize button
                    optimizeBtnEl.disabled = false;
                    exportBtnEl.disabled = false;
                    downloadBtnEl.disabled = false;
                    
                    // Scroll to analysis results
                    analysisSummaryEl.scrollIntoView({behavior: 'smooth'});
                } catch (error) {
                    console.error("Error during analysis:", error);
                    analysisSummaryEl.innerHTML = `
                        <div class="error">
                            <h3>Error analyzing data</h3>
                            <p>An unexpected error occurred: ${error.message}</p>
                            <p>Please check your input format and try again.</p>
                        </div>
                    `;
                }
            }, 300); // Small delay to allow loading indicator to show
        });
        
        optimizeBtnEl.addEventListener('click', function() {
            if (originalJobs.length === 0) {
                alert('Please analyze schedule data first.');
                return;
            }
            
            // Show loading indicator
            optimizationStatsEl.innerHTML = '<div class="loading">Optimizing schedule...</div>';
            
            setTimeout(() => {
                try {
                    // Get visible jobs
                    const visibleJobs = getVisibleJobs(originalJobs);
                    
                    // Optimize the schedule
                    optimizedJobs = optimizeSchedule(visibleJobs);
                    
                    // Display optimized schedule
                    displayOptimizedSchedule();
                    
                    // Switch to optimized tab
                    tabsEl.forEach(t => t.classList.remove('active'));
                    tabContentsEl.forEach(tc => tc.classList.remove('active'));
                    
                    document.querySelector('.tab[data-tab="optimized"]').classList.add('active');
                    document.getElementById('optimizedSchedule').classList.add('active');
                    
                    // Scroll to results
                    document.getElementById('optimizedSchedule').scrollIntoView({behavior: 'smooth'});
                } catch (error) {
                    console.error("Error during optimization:", error);
                    optimizationStatsEl.innerHTML = `
                        <div class="error">
                            <h3>Error optimizing schedule</h3>
                            <p>An unexpected error occurred: ${error.message}</p>
                        </div>
                    `;
                }
            }, 300);
        });
        
        exportBtnEl.addEventListener('click', function() {
            if (originalJobs.length === 0) {
                alert('Please analyze schedule data first.');
                return;
            }
            
            // Get all jobs, including optimized if available
            const jobsToExport = optimizedJobs.length > 0 ? optimizedJobs : originalJobs;
            
            // Get visible jobs
            const visibleJobs = getVisibleJobs(jobsToExport);
            
            // Sort jobs by press
            visibleJobs.sort((a, b) => a.press.localeCompare(b.press));
            
            // Convert to CSV format
            let csv = 'Press,Date,Start Time,Duration,Job ID,Ship Date,Customer,Die ID,Plate Count\n';
            
            visibleJobs.forEach(job => {
                csv += `${job.press},${job.date},${job.startTime},${job.duration},${job.jobId},${job.shipmentDate},${job.customer},${job.dieId},${job.plateCount}\n`;
            });
            
            // Copy to clipboard
            const textArea = document.createElement('textarea');
            textArea.value = csv;
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
            
            alert('Schedule copied to clipboard!');
        });
        
        downloadBtnEl.addEventListener('click', function() {
            if (originalJobs.length === 0) {
                alert('Please analyze schedule data first.');
                return;
            }
            
            // Get all jobs, including optimized if available
            const jobsToExport = optimizedJobs.length > 0 ? optimizedJobs : originalJobs;
            
            // Get visible jobs
            const visibleJobs = getVisibleJobs(jobsToExport);
            
            // Sort jobs by press
            visibleJobs.sort((a, b) => a.press.localeCompare(b.press));
            
            // Convert to CSV format
            let csv = 'Press,Date,Start Time,Duration,Job ID,Ship Date,Customer,Die ID,Plate Count\n';
            
            visibleJobs.forEach(job => {
                csv += `${job.press},${job.date},${job.startTime},${job.duration},${job.jobId},${job.shipmentDate},${job.customer},${job.dieId},${job.plateCount}\n`;
            });
            
            // Create download link
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.setAttribute('hidden', '');
            a.setAttribute('href', url);
            a.setAttribute('download', 'optimized_schedule.csv');
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        });
        
        // Helper Functions
        function parseScheduleData(data) {
            const lines = data.split('\n');
            const jobs = [];
            pressTypes = [];
            
            // Variables to track state
            let currentPress = "";
            let headerRow = null;
            let headerRowIndex = -1;
            let columnMap = {}; // Maps column names to indices
            
            // Detect data format based on content
            for (let i = 0; i < Math.min(10, lines.length); i++) {
                const line = lines[i].trim();
                if (line.toLowerCase().includes('date') && 
                    line.toLowerCase().includes('time') && 
                    (line.toLowerCase().includes('job') || line.toLowerCase().includes('id'))) {
                    headerRow = line;
                    headerRowIndex = i;
                    break;
                }
            }
            
            // If no header row found, try to be smart about it
            if (!headerRow) {
                console.log("No standard header row found, attempting to infer format...");
                
                // Look for any line with date pattern to guess if it's job data
                for (let i = 0; i < Math.min(10, lines.length); i++) {
                    const line = lines[i].trim();
                    // Check for date pattern like MM/DD/YYYY
                    if (/\d{1,2}\/\d{1,2}\/\d{2,4}/.test(line)) {
                        console.log("Found date pattern in line:", i);
                        headerRowIndex = i - 1; // Assume previous line might be header
                        if (headerRowIndex < 0) headerRowIndex = 0;
                        break;
                    }
                }
            }
            
            // Create default column mapping or use header row if available
            if (headerRow) {
                // Try to detect separator (tab or comma)
                const separator = headerRow.includes('\t') ? '\t' : ',';
                const headers = headerRow.split(separator);
                
                // Map column headers to indices
                headers.forEach((header, index) => {
                    const normalizedHeader = header.trim().toLowerCase();
                    columnMap[normalizedHeader] = index;
                });
                
                console.log("Detected columns:", Object.keys(columnMap));
            } else {
                // Default column mapping for different possible formats
                columnMap = {
                    "date": 0,
                    "start time": 1,
                    "duration": 2,
                    "job id": 3,
                    "ship date": 4,
                    "notes": 5,
                    "status": 6,
                    "customer": 7,
                    "description": 8,
                    "graphics": 9,
                    "plates": 10,
                    "plate count": 19,
                    "paper width": 20,
                    "substrate": 21,
                    "die id": 17
                };
            }
            
            // Function to safely get field value with fallbacks
            function getField(fields, key, defaultValue = '') {
                const index = columnMap[key.toLowerCase()];
                if (index !== undefined && index < fields.length) {
                    return fields[index];
                }
                
                // Fallback: Try to find by similar column name
                const similarKeys = Object.keys(columnMap).filter(k => 
                    k.includes(key.toLowerCase()) || key.toLowerCase().includes(k));
                
                if (similarKeys.length > 0) {
                    return fields[columnMap[similarKeys[0]]];
                }
                
                return defaultValue;
            }
            
            // Process each line
            for (let i = 0; i < lines.length; i++) {
                // Skip header row
                if (i === headerRowIndex) continue;
                
                const line = lines[i].trim();
                if (line === '') continue;
                
                // Check if line is a press header
                if (line.includes('_SMAG') || line.includes('_ROTO') || 
                    line.includes('_MA_P7') || line.includes('_T-180') ||
                    /^PRESS_/.test(line)) {
                    currentPress = line.trim();
                    
                    // Add to press types if not already there
                    if (!pressTypes.includes(currentPress)) {
                        pressTypes.push(currentPress);
                    }
                    
                    continue;
                }
                
                // Skip header row variations
                if (line.startsWith('Date') || line.startsWith('Calculation')) continue;
                
                // Determine separator - default to tab, but check for comma if tab not found
                const separator = line.includes('\t') ? '\t' : ',';
                const fields = line.split(separator);
                
                // More flexible validation for job data lines
                // Look for date pattern instead of relying on specific field count
                const potentialDateField = fields[0];
                const hasDate = potentialDateField && 
                              (/\d{1,2}\/\d{1,2}\/\d{2,4}/.test(potentialDateField) ||
                               /\d{4}-\d{1,2}-\d{1,2}/.test(potentialDateField));
                
                if (fields.length > 3 && hasDate) {
                    try {
                        const job = {
                            press: currentPress,
                            date: getField(fields, 'date'),
                            dateObj: parseDate(getField(fields, 'date')),
                            startTime: getField(fields, 'start time'),
                            duration: getField(fields, 'duration'),
                            durationMinutes: parseDuration(getField(fields, 'duration')),
                            jobId: getField(fields, 'job id'),
                            shipmentDate: getField(fields, 'ship date'),
                            shipDateObj: parseDate(getField(fields, 'ship date')),
                            notes: getField(fields, 'notes'),
                            status: getField(fields, 'status'),
                            customer: getField(fields, 'customer'),
                            description: getField(fields, 'description'),
                            graphics: getField(fields, 'graphics'),
                            plates: getField(fields, 'plates'),
                            plateCount: getField(fields, 'plate count', '0'),
                            paperWidth: getField(fields, 'paper width'),
                            substrate: getField(fields, 'substrate'),
                            dieId: getField(fields, 'die id'),
                            colorCategory: getColorCategory(getField(fields, 'plate count', '0')),
                            optimized: false
                        };
                        
                        // If we're missing critical info, try to infer from other fields
                        if (!job.press && currentPress) {
                            job.press = currentPress;
                        }
                        
                        if (!job.plateCount || job.plateCount === '0') {
                            // Try to infer plate count from other fields if missing
                            if (job.plates && job.plates.match(/\d+/)) {
                                // Extract numbers from plates field
                                const numbers = job.plates.match(/\d+/g);
                                if (numbers && numbers.length > 0) {
                                    job.plateCount = numbers[0];
                                    job.colorCategory = getColorCategory(job.plateCount);
                                }
                            }
                        }
                        
                        // Calculate urgency based on ship date
                        if (job.shipDateObj) {
                            const daysToShip = daysBetween(today, job.shipDateObj);
                            job.daysToShip = daysToShip;
                            job.isUrgent = daysToShip <= 3;
                            job.isApproachingDue = daysToShip <= 7 && daysToShip > 3;
                        }
                        
                        // Validate job data - ensure we have the minimum required fields
                        if (job.date) {
                            jobs.push(job);
                        }
                    } catch (error) {
                        console.error("Error processing job data:", error);
                        console.warn("Problematic line:", line);
                        // Continue processing other lines despite this error
                    }
                }
            }
            
            console.log(`Successfully parsed ${jobs.length} jobs`);
            return jobs;
        }
        
        function parseDate(dateStr) {
            if (!dateStr) return null;
            
            // Normalize the date string
            dateStr = dateStr.trim();
            
            // Try to parse the date in MM/DD/YYYY format
            let parts = dateStr.split('/');
            if (parts.length === 3) {
                let year = parseInt(parts[2]);
                // Adjust two-digit years
                if (year < 100) {
                    year += year < 50 ? 2000 : 1900;
                }
                
                // Month is 0-based in JavaScript Date
                const month = parseInt(parts[0]) - 1;
                const day = parseInt(parts[1]);
                
                return new Date(year, month, day);
            }
            
            // Try YYYY-MM-DD format
            if (/^\d{4}-\d{1,2}-\d{1,2}$/.test(dateStr)) {
                parts = dateStr.split('-');
                return new Date(
                    parseInt(parts[0]), 
                    parseInt(parts[1]) - 1, 
                    parseInt(parts[2])
                );
            }
            
            // Try DD-MM-YYYY format
            if (/^\d{1,2}-\d{1,2}-\d{4}$/.test(dateStr)) {
                parts = dateStr.split('-');
                return new Date(
                    parseInt(parts[2]), 
                    parseInt(parts[1]) - 1, 
                    parseInt(parts[0])
                );
            }
            
            // Try using the built-in date parser as a fallback
            const parsed = new Date(dateStr);
            if (!isNaN(parsed.getTime())) {
                return parsed;
            }
            
            return null;
        }
        
        function parseDuration(duration) {
            if (!duration) return 0;
            
            const parts = duration.split(':');
            if (parts.length === 2) {
                return parseInt(parts[0]) * 60 + parseInt(parts[1]);
            } else if (parts.length === 3) {
                return parseInt(parts[0]) * 60 + parseInt(parts[1]);
            }
            return 0;
        }
        
        function getColorCategory(plateCount) {
            if (!plateCount) return 'unknown';
            const count = parseInt(plateCount);
            
            if (count === 1) return 'single'; // Single color
            if (count === 4) return 'process'; // 4-color process
            if (count > 4) return 'complex'; // Complex (more than 4 colors)
            return 'multi'; // Multiple colors but not 4-color process
        }
        
        function daysBetween(date1, date2) {
            const oneDay = 24 * 60 * 60 * 1000; // hours*minutes*seconds*milliseconds
            return Math.round(Math.abs((date1 - date2) / oneDay));
        }
        
        function getChangeoverTimes() {
            return {
                die: parseInt(dieTimeEl.value) || 15,
                material: parseInt(materialTimeEl.value) || 10,
                color: parseInt(colorTimeEl.value) || 3
            };
        }
        
        function countChangeovers(jobs) {
            // Sort jobs by press and date
            const sortedJobs = [...jobs].sort((a, b) => {
                if (a.press !== b.press) {
                    return a.press.localeCompare(b.press);
                }
                return a.dateObj - b.dateObj;
            });
            
            let dieChanges = 0;
            let materialChanges = 0;
            let colorChanges = 0;
            
            // Analyze job by job
            for (let i = 1; i < sortedJobs.length; i++) {
                const prevJob = sortedJobs[i-1];
                const currentJob = sortedJobs[i];
                
                // Skip if different press
                if (prevJob.press !== currentJob.press) continue;
                
                // Check for die change
                if (prevJob.dieId !== currentJob.dieId && prevJob.dieId && currentJob.dieId) {
                    dieChanges++;
                }
                
                // Check for material change
                if (prevJob.substrate !== currentJob.substrate && prevJob.substrate && currentJob.substrate) {
                    materialChanges++;
                }
                
                // Check for color change (simplified)
                if (prevJob.colorCategory !== currentJob.colorCategory) {
                    colorChanges++;
                }
            }
            
            // Calculate total changeover time
            const changeoverTimes = getChangeoverTimes();
            const totalChangeoverMinutes = 
                dieChanges * changeoverTimes.die + 
                materialChanges * changeoverTimes.material + 
                colorChanges * changeoverTimes.color;
            
            return {
                dieChanges,
                materialChanges,
                colorChanges,
                totalChangeoverMinutes
            };
        }
        
        function createAnalysisSummary(jobs) {
            const stats = countChangeovers(jobs);
            const changeoverTime = getChangeoverTimes();
            
            // Count job types
            let singleColorJobs = 0;
            let processColorJobs = 0;
            let multiColorJobs = 0;
            let complexColorJobs = 0;
            let jobsWithDie = 0;
            
            jobs.forEach(job => {
                if (job.colorCategory === 'single') {
                    singleColorJobs++;
                } else if (job.colorCategory === 'process') {
                    processColorJobs++;
                } else if (job.colorCategory === 'multi') {
                    multiColorJobs++;
                } else if (job.colorCategory === 'complex') {
                    complexColorJobs++;
                }
                
                if (job.dieId && job.dieId !== '') {
                    jobsWithDie++;
                }
            });
            
            // Group by press
            const pressJobs = {};
            pressTypes.forEach(press => {
                pressJobs[press] = jobs.filter(job => job.press === press);
            });
            
            // Generate HTML
            let html = `
                <div class="stats">
                    <div class="stat-card">
                        <div>Total Jobs</div>
                        <div class="stat-value">${jobs.length}</div>
                    </div>
                    <div class="stat-card">
                        <div>Die Changes</div>
                        <div class="stat-value">${stats.dieChanges}</div>
                    </div>
                    <div class="stat-card">
                        <div>Material Changes</div>
                        <div class="stat-value">${stats.materialChanges}</div>
                    </div>
                    <div class="stat-card">
                        <div>Jobs with Dies</div>
                        <div class="stat-value">${jobsWithDie}</div>
                    </div>
                </div>
                
                <h3>Changeover Time Analysis</h3>
                <p>Based on your parameters:</p>
                <ul>
                    <li>Die changes (${stats.dieChanges} × ${changeoverTime.die} min) = ${stats.dieChanges * changeoverTime.die} minutes</li>
                    <li>Material changes (${stats.materialChanges} × ${changeoverTime.material} min) = ${stats.materialChanges * changeoverTime.material} minutes</li>
                </ul>
                <p>Total changeover time: ${stats.totalChangeoverMinutes} minutes (${Math.floor(stats.totalChangeoverMinutes/60)} hours and ${stats.totalChangeoverMinutes % 60} minutes)</p>
                
                <h3>Color Complexity Analysis</h3>
                <ul>
                    <li><strong>Single Color Jobs:</strong> ${singleColorJobs} (${Math.round(singleColorJobs/jobs.length*100)}%)</li>
                    <li><strong>4-Color Process Jobs:</strong> ${processColorJobs} (${Math.round(processColorJobs/jobs.length*100)}%)</li>
                    <li><strong>Other Multi-Color Jobs:</strong> ${multiColorJobs} (${Math.round(multiColorJobs/jobs.length*100)}%)</li>
                    <li><strong>Complex Color Jobs (5+ colors):</strong> ${complexColorJobs} (${Math.round(complexColorJobs/jobs.length*100)}%)</li>
                </ul>
                
                <h3>Press Distribution</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Press</th>
                            <th>Jobs</th>
                            <th>Die Changes</th>
                            <th>Material Changes</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            // Add row for each press
            Object.entries(pressJobs).forEach(([press, pressJobsList]) => {
                // Count changeovers for this press
                const pressStats = countChangeovers(pressJobsList);
                
                html += `
                    <tr>
                        <td>${press}</td>
                        <td>${pressJobsList.length}</td>
                        <td>${pressStats.dieChanges}</td>
                        <td>${pressStats.materialChanges}</td>
                    </tr>
                `;
            });
            
            html += `
                    </tbody>
                </table>
                
                <h3>Optimization Opportunities</h3>
                <p>There are potential opportunities to reduce changeover time by reordering jobs to minimize die changes and material waste. Click "Optimize Schedule" to see the optimized version.</p>
            `;
            
            return html;
        }
        
        function createPressSelectors() {
            // Create press selection checkboxes
            let html = '<h3>Filter by Press</h3>';
            
            pressTypes.forEach(press => {
                html += `
                    <label class="press-checkbox">
                        <input type="checkbox" class="press-filter" value="${press}" checked>
                        ${press}
                    </label>
                `;
            });
            
            pressSelectorsEl.innerHTML = html;
            
            // Set initial selected presses
            selectedPresses = [...pressTypes];
            
            // Add event listeners
            const checkboxes = document.querySelectorAll('.press-filter');
            checkboxes.forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    const press = this.value;
                    
                    if (this.checked) {
                        // Add to selected presses
                        if (!selectedPresses.includes(press)) {
                            selectedPresses.push(press);
                        }
                    } else {
                        // Remove from selected presses
                        const index = selectedPresses.indexOf(press);
                        if (index !== -1) {
                            selectedPresses.splice(index, 1);
                        }
                    }
                    
                    // Update displays
                    displayOriginalSchedule();
                    
                    if (optimizedJobs.length > 0) {
                        displayOptimizedSchedule();
                    }
                });
            });
        }
        
        function getVisibleJobs(jobs) {
            return jobs.filter(job => selectedPresses.includes(job.press));
        }
        
        function displayOriginalSchedule() {
            const visibleJobs = getVisibleJobs(originalJobs);
            
            // Sort jobs by press and date
            const sortedJobs = [...visibleJobs].sort((a, b) => {
                if (a.press !== b.press) {
                    return a.press.localeCompare(b.press);
                }
                
                if (a.dateObj && b.dateObj) {
                    return a.dateObj - b.dateObj;
                }
                
                return 0;
            });
            
            // Create table
            let html = '';
            
            sortedJobs.forEach((job, index) => {
                // Determine row classes
                const classes = [];
                
                if (job.isUrgent) {
                    classes.push('urgent');
                } else if (job.isApproachingDue) {
                    classes.push('approaching-due');
                }
                
                // Check for changeovers
                if (index > 0) {
                    const prevJob = sortedJobs[index-1];
                    
                    // Skip if different press
                    if (prevJob.press === job.press) {
                        if (prevJob.dieId === job.dieId && prevJob.dieId) {
                            classes.push('same-die');
                        }
                        
                        if (prevJob.substrate === job.substrate && prevJob.substrate) {
                            classes.push('same-substrate');
                        }
                    }
                }
                
                html += `
                    <tr class="${classes.join(' ')}">
                        <td>${job.date}</td>
                        <td>${job.startTime}</td>
                        <td>${job.duration}</td>
                        <td>${job.jobId}</td>
                        <td>${job.shipmentDate}</td>
                        <td>${job.status}</td>
                        <td>${job.customer}</td>
                        <td>${job.dieId}</td>
                        <td>${job.plateCount}</td>
                    </tr>
                `;
            });
            
            originalTableEl.querySelector('tbody').innerHTML = html;
        }
        
        function optimizeSchedule(jobs) {
            // Clone jobs to avoid modifying originals
            const jobsToOptimize = JSON.parse(JSON.stringify(jobs));
            
            // Get optimization parameters
            const prioritizeShipDates = prioritizeShipDatesEl.checked;
            const groupByDie = groupByDieEl.checked;
            
            // Group jobs by press
            const pressBatches = {};
            
            pressTypes.forEach(press => {
                pressBatches[press] = jobsToOptimize.filter(job => job.press === press);
            });
            
            // Optimize each press separately
            Object.keys(pressBatches).forEach(press => {
                const pressJobs = pressBatches[press];
                
                // Sort by ship date if prioritizing ship dates
                if (prioritizeShipDates) {
                    pressJobs.sort((a, b) => {
                        if (a.shipDateObj && b.shipDateObj) {
                            return a.shipDateObj - b.shipDateObj;
                        }
                        return 0;
                    });
                }
                
                // Group by die ID if enabled
                if (groupByDie) {
                    // Group jobs by die ID
                    const dieGroups = {};
                    
                    pressJobs.forEach(job => {
                        if (job.dieId && job.dieId !== '') {
                            if (!dieGroups[job.dieId]) {
                                dieGroups[job.dieId] = [];
                            }
                            dieGroups[job.dieId].push(job);
                        }
                    });
                    
                    // Sort die groups by earliest ship date
                    const sortedDieGroups = Object.entries(dieGroups).sort(([, jobsA], [, jobsB]) => {
                        const earliestShipDateA = Math.min(...jobsA.map(job => job.shipDateObj ? job.shipDateObj.getTime() : Infinity));
                        const earliestShipDateB = Math.min(...jobsB.map(job => job.shipDateObj ? job.shipDateObj.getTime() : Infinity));
                        return earliestShipDateA - earliestShipDateB;
                    });
                    
                    // Replace press jobs with optimized sequence
                    pressBatches[press] = [];
                    
                    // Add jobs with dies in optimized order
                    sortedDieGroups.forEach(([dieId, dieJobs]) => {
                        // Sort by substrate to minimize material changes
                        dieJobs.sort((a, b) => {
                            if (a.substrate && b.substrate) {
                                return a.substrate.localeCompare(b.substrate);
                            }
                            return 0;
                        });
                        
                        pressBatches[press] = [...pressBatches[press], ...dieJobs];
                    });
                    
                    // Add jobs without dies
                    const jobsWithoutDies = pressJobs.filter(job => !job.dieId || job.dieId === '');
                    pressBatches[press] = [...pressBatches[press], ...jobsWithoutDies];
                } else {
                    // Simple optimization by substrate
                    pressJobs.sort((a, b) => {
                        if (a.substrate && b.substrate) {
                            return a.substrate.localeCompare(b.substrate);
                        }
                        return 0;
                    });
                    pressBatches[press] = pressJobs;
                }
                
                // Mark jobs as optimized
                pressBatches[press].forEach(job => {
                    job.optimized = true;
                });
            });
            
            // Combine all optimized jobs
            const optimizedJobs = [];
            Object.values(pressBatches).forEach(batch => {
                optimizedJobs.push(...batch);
            });
            
            return optimizedJobs;
        }
        
        function displayOptimizedSchedule() {
            const visibleJobs = getVisibleJobs(optimizedJobs);
            
            // Sort jobs by press
            const sortedJobs = [...visibleJobs].sort((a, b) => {
                return a.press.localeCompare(b.press);
            });
            
            // Calculate changeovers
            const originalStats = countChangeovers(getVisibleJobs(originalJobs));
            const optimizedStats = countChangeovers(sortedJobs);
            
            const changeoverTime = getChangeoverTimes();
            
            // Calculate savings
            const originalMinutes = originalStats.totalChangeoverMinutes;
            const optimizedMinutes = optimizedStats.totalChangeoverMinutes;
            const savedMinutes = originalMinutes - optimizedMinutes;
            const savedPercentage = Math.round((savedMinutes / originalMinutes) * 100);
            
            // Display optimization stats
            let statsHtml = `
                <div class="success-message">
                    <h3>Optimization Results</h3>
                    <p>Optimized schedule reduces changeover time by ${savedMinutes} minutes (${savedPercentage}% reduction).</p>
                </div>
                
                <div class="stats">
                    <div class="stat-card">
                        <div>Original Changeover Time</div>
                        <div class="stat-value">${originalMinutes} min</div>
                        <small>(${Math.floor(originalMinutes/60)} hours, ${originalMinutes % 60} min)</small>
                    </div>
                    
                    <div class="stat-card">
                        <div>Optimized Changeover Time</div>
                        <div class="stat-value">${optimizedMinutes} min</div>
                        <small>(${Math.floor(optimizedMinutes/60)} hours, ${optimizedMinutes % 60} min)</small>
                    </div>
                    
                    <div class="stat-card">
                        <div>Time Saved</div>
                        <div class="stat-value">${savedMinutes} min</div>
                        <small>(${Math.floor(savedMinutes/60)} hours, ${savedMinutes % 60} min)</small>
                    </div>
                    
                    <div class="stat-card">
                        <div>Die Changes</div>
                        <div class="stat-value">${originalStats.dieChanges} → ${optimizedStats.dieChanges}</div>
                        <small>Reduced by ${originalStats.dieChanges - optimizedStats.dieChanges}</small>
                    </div>
                    
                    <div class="stat-card">
                        <div>Material Changes</div>
                        <div class="stat-value">${originalStats.materialChanges} → ${optimizedStats.materialChanges}</div>
                        <small>Reduced by ${originalStats.materialChanges - optimizedStats.materialChanges}</small>
                    </div>
                </div>
                
                <p>The optimized schedule groups jobs by similar die and material to minimize changeover time while respecting ship dates.</p>
            `;
            
            optimizationStatsEl.innerHTML = statsHtml;
            
            // Create table
            let html = '';
            
            sortedJobs.forEach((job, index) => {
                // Determine row classes
                const classes = [];
                
                if (job.isUrgent) {
                    classes.push('urgent');
                } else if (job.isApproachingDue) {
                    classes.push('approaching-due');
                }
                
                // Check for changeovers
                if (index > 0) {
                    const prevJob = sortedJobs[index-1];
                    
                    // Skip if different press
                    if (prevJob.press === job.press) {
                        if (prevJob.dieId === job.dieId && prevJob.dieId) {
                            classes.push('same-die');
                        }
                        
                        if (prevJob.substrate === job.substrate && prevJob.substrate) {
                            classes.push('same-substrate');
                        }
                    }
                }
                
                // Add optimized class
                classes.push('optimized');
                
                html += `
                    <tr class="${classes.join(' ')}">
                        <td>${job.date}</td>
                        <td>${job.startTime}</td>
                        <td>${job.duration}</td>
                        <td>${job.jobId}</td>
                        <td>${job.shipmentDate}</td>
                        <td>${job.status}</td>
                        <td>${job.customer}</td>
                        <td>${job.dieId}</td>
                        <td>${job.plateCount}</td>
                    </tr>
                `;
            });
            
            optimizedTableEl.querySelector('tbody').innerHTML = html;
            
            // Create timeline visualization
            createTimelineVisualization(sortedJobs);
        }
        
        function createTimelineVisualization(jobs) {
            // Group jobs by press
            const pressBatches = {};
            
            pressTypes.forEach(press => {
                pressBatches[press] = jobs.filter(job => job.press === press);
            });
            
            // Create timeline HTML
            let html = '';
            
            Object.entries(pressBatches).forEach(([press, pressJobs]) => {
                if (pressJobs.length === 0) return;
                
                html += `<div class="timeline-track">`;
                html += `<div class="timeline-label">${press}</div>`;
                
                // Sort jobs by sequence
                pressJobs.sort((a, b) => {
                    // Use their order in the array
                    return jobs.indexOf(a) - jobs.indexOf(b);
                });
                
                // Calculate total width
                const totalWidth = 1000; // pixels
                const totalMinutes = pressJobs.reduce((total, job) => total + (job.durationMinutes || 60), 0);
                const pixelsPerMinute = totalWidth / totalMinutes;
                
                // Track current position
                let position = 0;
                
                // Add each job
                pressJobs.forEach((job, index) => {
                    // Determine job width
                    const width = (job.durationMinutes || 60) * pixelsPerMinute;
                    
                    // Determine class
                    const classes = ['timeline-job'];
                    
                    if (job.isUrgent) {
                        classes.push('urgent');
                    }
                    
                    // Check for changeovers
                    if (index > 0) {
                        const prevJob = pressJobs[index-1];
                        
                        if (prevJob.dieId === job.dieId && prevJob.dieId) {
                            classes.push('same-die');
                        }
                        
                        if (prevJob.substrate === job.substrate && prevJob.substrate) {
                            classes.push('same-substrate');
                        }
                    }
                    
                    html += `
                        <div class="${classes.join(' ')}" style="left: ${position}px; width: ${width}px;" 
                             title="${job.customer} - ${job.jobId} - ${job.dieId || 'No Die'}">
                            ${job.jobId.substring(0, 8)}
                        </div>
                    `;
                    
                    position += width;
                });
                
                html += `</div>`;
            });
            
            // Add timeline scale
            html += `<div class="timeline-scale">`;
            
            // Add markers
            const numMarkers = 10;
            for (let i = 0; i <= numMarkers; i++) {
                const position = (i / numMarkers) * 100;
                html += `
                    <div class="timeline-marker" style="left: ${position}%">
                        ${i}
                    </div>
                `;
            }
            
            html += `</div>`;
            
            timelineContainerEl.innerHTML = html;
        }
    </script>
</body>
</html>
